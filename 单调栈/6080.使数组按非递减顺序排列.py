# 给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] > nums[i] 的 nums[i] ，其中 0 < i < nums.length 。
#
# 重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。
#
#  
#
# 示例 1：
#
# 输入：nums = [5,3,4,4,7,3,6,11,8,5,11]
# 输出：3
# 解释：执行下述几个步骤：
# - 步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11]
# - 步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11]
# - 步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11]
# [5,7,11,11] 是一个非递减数组，因此，返回 3 。
# 示例 2：
#
# 输入：nums = [4,5,7,7,13]
# 输出：0
# 解释：nums 已经是一个非递减数组，因此，返回 0 。
class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        # 记录每个数被移除的时刻
        # 这些时刻的最大值就是答案
        # 维护一个单调减栈和每个数删除的时刻
        # 存数字和弹出时间
        stack = []
        ans = 0
        for num in nums:
            max_t = 0
            while stack and stack[-1][0] <= num:
                max_t = max(max_t, stack.pop()[1])
            if stack:
                max_t += 1

            ans = max(ans, max_t)
            stack.append((num, max_t))
            # print(stack,num)
        return ans

        # 为什么这样写，举个例子 [9,1,2,3,1,5]
        # 对于删除元素 5 我只想知道删除元素3的最大值
        # 对于 2 我想知道 1， 对于3我想知道2
        # 如果前面有个小于等于当前值的元素，那么，当前位置删除的时刻一定在这个元素之后
        # 然而需要找到当前值被哪个值删除 和 当前值左边最大的小于等于当前值的数被删除的时刻，则当前数被删除的时刻是那个数的时刻 + 1
        # 如果栈为空，说明当前值左边没有大于它的数，它不会被删除，所以栈非空max_t才会+1