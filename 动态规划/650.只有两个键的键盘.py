# 最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：
#
# Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
# Paste（粘贴）：粘贴 上一次 复制的字符。
# 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。
#
#  
#
# 示例 1：
#
# 输入：3
# 输出：3
# 解释：
# 最初, 只有一个字符 'A'。
# 第 1 步, 使用 Copy All 操作。
# 第 2 步, 使用 Paste 操作来获得 'AA'。
# 第 3 步, 使用 Paste 操作来获得 'AAA'。
# 示例 2：
#
# 输入：n = 1
# 输出：0
class Solution:
    def minSteps(self, n: int) -> int:
        # 6个 A 1. 先从 1. A->AA->AAAA->AAAAAA   5 步(2*3=6 2+3=5)  2.A->AAA->AAAAAAA 5步(3*2=6, 3+2=5)
        # 分解质因数
        # dp定义
        # dp转移
        # dp初始化
        dp = [0]*(n+1)
        for i in range(2, n+1):
            # 这个是变成长度i的最大次数
            dp[i] = i
            # 当在2到i开方没有因数就可以判断它没有质因数
            for j in range(2, int(sqrt(i))+1):
                # 找到第一个因数即可
                # 因为dp[j]和dp[i//j]分别对应了各个长度的最小操作，使得和也为最小
                if i % j ==0 :
                    dp[i] = dp[j] + dp[i//j]
                    break
        return dp[-1]
