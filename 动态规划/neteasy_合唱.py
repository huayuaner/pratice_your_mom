# 小Q和牛博士合唱一首歌曲,这首歌曲由n个音调组成,每个音调由一个正整数表示。
# 对于每个音调要么由小Q演唱要么由牛博士演唱,对于一系列音调演唱的难度等于所有相邻音调变化幅度之和, 例如一个音调序列是8, 8, 13, 12, 那么它的难度等于|8 - 8| + |13 - 8| + |12 - 13| = 6(其中||表示绝对值)。
# 现在要对把这n个音调分配给小Q或牛博士,让他们演唱的难度之和最小,请你算算最小的难度和是多少。
# 如样例所示: 小Q选择演唱{5, 6}难度为1, 牛博士选择演唱{1, 2, 1}难度为2,难度之和为3,这一个是最小难度和的方案了。


n = int(input())
music = list(map(int, input().split()))
if n<=2:
    print(0)
# dp[i][j]表示Q唱到i，牛唱到j的难度和
dp = [[0 for _ in range(n)] for _ in range(n)]
# 初始化
for i in range(2, n):
    # 表示一个人把除了开头的全唱了
    dp[i][0] = dp[i-1][0] + abs(music[i]-music[i-1])
    # 一个人把除了末尾的全唱了
    dp[i][i-1] = dp[i-1][i-2] + abs(music[i-1]-music[i-2])
for i in range(2, n):
    for j in range(i-1):
        # 没换人唱 i的前一个音就是i-1
        dp[i][j] = dp[i-1][j] + abs(music[i]-music[i-1])
        # 换人唱了， 这时i的前面一个音调是(0=< 前一个 <i-1)也就是j中最小的
        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j] + abs(music[i]- music[j]))
# 最后一定是两个的一个唱到n-1，一个唱到n-2
print(min(dp[n-1][:-1]))
